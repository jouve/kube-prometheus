local grafana = import './kube-prometheus/components/grafana.libsonnet';
local kubernetesControlPlane = import './kube-prometheus/components/k8s-control-plane.libsonnet';
local kubeStateMetrics = import './kube-prometheus/components/kube-state-metrics.libsonnet';
local customMixin = import './kube-prometheus/components/mixin/custom.libsonnet';
local nodeExporter = import './kube-prometheus/components/node-exporter.libsonnet';
local kp =
  {
  // using `values` as this is similar to helm
  values:: {
    common: {
      namespace: 'monitoring',
      platform: null,
      ruleLabels: {
        role: 'alert-rules',
        prometheus: 'k8s',
      },
      // to allow automatic upgrades of components, we store versions in autogenerated `versions.json` file and import it here
      versions: {
        grafana: error 'must provide version',
        kubeStateMetrics: error 'must provide version',
        nodeExporter: error 'must provide version',
        kubeRbacProxy: error 'must provide version',
        configmapReload: error 'must provide version',
      } + (import './kube-prometheus/versions.json'),
      images: {
        grafana: 'grafana/grafana:' + $.values.common.versions.grafana,
        kubeStateMetrics: 'registry.k8s.io/kube-state-metrics/kube-state-metrics:v' + $.values.common.versions.kubeStateMetrics,
        nodeExporter: 'quay.io/prometheus/node-exporter:v' + $.values.common.versions.nodeExporter,
        kubeRbacProxy: 'quay.io/brancz/kube-rbac-proxy:v' + $.values.common.versions.kubeRbacProxy,
        configmapReload: 'ghcr.io/jimmidyson/configmap-reload:v' + $.values.common.versions.configmapReload,
      },
    },
    grafana: {
      namespace: $.values.common.namespace,
      version: $.values.common.versions.grafana,
      image: $.values.common.images.grafana,
      prometheusName: 'k8s',
      dashboards: {
        [name]: $[component].mixin.grafanaDashboards[name]
        for component in std.objectFields($)
        if std.objectHasAll(std.get($[component], 'mixin', {}), 'grafanaDashboards')
        for name in std.objectFields($[component].mixin.grafanaDashboards)
      },
      mixin+: { ruleLabels: $.values.common.ruleLabels },
    },
    kubeStateMetrics: {
      namespace: $.values.common.namespace,
      version: $.values.common.versions.kubeStateMetrics,
      image: $.values.common.images.kubeStateMetrics,
      mixin+: { ruleLabels: $.values.common.ruleLabels },
      kubeRbacProxyImage: $.values.common.images.kubeRbacProxy,
    },
    nodeExporter: {
      namespace: $.values.common.namespace,
      version: $.values.common.versions.nodeExporter,
      image: $.values.common.images.nodeExporter,
      mixin+: { ruleLabels: $.values.common.ruleLabels },
      kubeRbacProxyImage: $.values.common.images.kubeRbacProxy,
    },
    kubernetesControlPlane: {
      namespace: $.values.common.namespace,
      mixin+: {
        ruleLabels: $.values.common.ruleLabels,
        _config+:: {
          cadvisorSelector: 'job="integrations/kubernetes/cadvisor"',
          kubeApiserverSelector: 'job="integrations/kubernetes/kube-apiserver"',
          kubeletSelector: 'job="integrations/kubernetes/kubelet"',
          kubeStateMetricsSelector: 'job="integrations/kubernetes/kube-state-metrics"',
          nodeExporterSelector: 'job="integrations/node_exporter"',
          windowsExporterSelector: 'job="integrations/windows_exporter"',
        },
      },
    },
    kubePrometheus: {
      namespace: $.values.common.namespace,
      mixin+: { ruleLabels: $.values.common.ruleLabels },
    },
  },

  grafana: {
    dashboardDefinitions: grafana($.values.grafana).dashboardDefinitions,
  },
  kubeStateMetrics: {
    prometheusRule: kubeStateMetrics($.values.kubeStateMetrics).prometheusRule,
    mixin:: kubeStateMetrics($.values.kubeStateMetrics).mixin,
  },
  nodeExporter: {
    prometheusRule: nodeExporter($.values.nodeExporter).prometheusRule,
    mixin:: nodeExporter($.values.nodeExporter).mixin,
  },
  kubernetesControlPlane: {
    prometheusRule: kubernetesControlPlane($.values.kubernetesControlPlane).prometheusRule,
    mixin:: kubernetesControlPlane($.values.kubernetesControlPlane).mixin,
  },
  kubePrometheus: customMixin($.values.kubePrometheus),
};

local manifests =
  {
    ['setup/' + resource]: kp[component][resource]
    for component in std.objectFields(kp)
    for resource in std.filter(
      function(resource)
        kp[component][resource].kind == 'CustomResourceDefinition' || kp[component][resource].kind == 'Namespace', std.objectFields(kp[component])
    )
  } +
  {
    [component + '-' + resource]: kp[component][resource]
    for component in std.objectFields(kp)
    for resource in std.filter(
      function(resource)
        kp[component][resource].kind != 'CustomResourceDefinition' && kp[component][resource].kind != 'Namespace', std.objectFields(kp[component])
    )
  };

local kustomizationResourceFile(name) = './manifests/' + name + '.yaml';
local kustomization = {
  apiVersion: 'kustomize.config.k8s.io/v1beta1',
  kind: 'Kustomization',
  resources: std.map(kustomizationResourceFile, std.objectFields(manifests)),
};

manifests {
  '../kustomization': kustomization,
}
